package payloadcms

import (
	"fmt"
	"html/template"
	"io"
	"sort"
	"time"

	"github.com/ainsleydev/webkit/pkg/apis/payloadcms/internal/templates"
)

// Meta defines the data generated by the SEO plugin from Payload
// along with additional fields such as Private & Canonical.
//
// The SEO plugin appears in the majority of collections and in both
// the Global Settings and Page level fields.
type Meta struct {
	Title          *string `json:"title,omitempty"`
	Description    *string `json:"description,omitempty"`
	Image          *int    `json:"image,omitempty"`
	Private        *bool   `json:"private,omitempty"`
	CanonicalURL   *string `json:"canonicalURL,omitempty"`
	StructuredData any     `json:"structuredData,omitempty"`
}

// Settings defines the common global collection type within Payload
// that allows users to change site settings.
type Settings struct {
	Id            float64        `json:"id"`
	SiteName      *string        `json:"siteName,omitempty"`
	TagLine       *string        `json:"tagLine,omitempty"`
	Locale        string         `json:"locale,omitempty"` // In en_GB format
	Logo          *int           `json:"logo,omitempty"`
	Meta          Meta           `json:"meta"`
	Robots        *string        `json:"robots,omitempty"`
	CodeInjection *CodeInjection `json:"codeInjection,omitempty"`
	Maintenance   *Maintenance   `json:"maintenance,omitempty"`
	Contact       *Contact       `json:"contact,omitempty"`
	UpdatedAt     *time.Time     `json:"updatedAt,omitempty"`
	CreatedAt     *time.Time     `json:"createdAt,omitempty"`
}

// CodeInjection defines the fields for injecting code into the head
// or foot of the frontend.
type CodeInjection struct {
	Footer *string `json:"footer,omitempty"`
	Head   *string `json:"head,omitempty"`
}

// Maintenance defines the fields for displaying an offline page to
// the front-end when it's been enabled within PayloadCMS.
type Maintenance struct {
	Content *string `json:"content,omitempty"`
	Enabled *bool   `json:"enabled,omitempty"`
	Title   *string `json:"title,omitempty"`
}

// Contact defines the fields for Contact Details within PayloadCMS.
type Contact struct {
	Address   *string `json:"address,omitempty"`
	Email     *string `json:"email,omitempty"`
	Facebook  *string `json:"facebook,omitempty"`
	Instagram *string `json:"instagram,omitempty"`
	LinkedIn  *string `json:"linkedIn,omitempty"`
	Telephone *string `json:"telephone,omitempty"`
	Tiktok    *string `json:"tiktok,omitempty"`
	X         *string `json:"x,omitempty"`
	Youtube   *string `json:"youtube,omitempty"`
}

// Media defines the fields for media when they are uploaded to PayloadCMS.
type Media struct {
	Id  float64 `json:"id"`
	Alt string  `json:"alt"`
	// TODO, need to parse RichText
	Caption   []map[string]any `json:"caption,omitempty"`
	MediaSize                  // The original
	Sizes     MediaSizes       `json:"sizes,omitempty"`
	CreatedAt string           `json:"createdAt"`
	UpdatedAt string           `json:"updatedAt" `
}

// MediaSizes defines a dictionary of media sizes by size name
// (e.g. "small", "medium", "large").
type MediaSizes map[string]MediaSize

// MediaSize defines the fields for the different sizes of media when they
// are uploaded to PayloadCMS.
type MediaSize struct {
	Size     string   `json:"-"`
	MediaSrc string   `json:"-"` // (min-width: 600px)
	URL      *string  `json:"url,omitempty"`
	Filename *string  `json:"filename,omitempty"`
	Filesize *float64 `json:"filesize,omitempty"`
	MimeType *string  `json:"mimeType,omitempty"`
	Width    *float64 `json:"width,omitempty"`
	Height   *float64 `json:"height,omitempty"`
}

// mediaByWidth implements sort.Interface for sorting MediaSize by Width.
type mediaByWidth []MediaSize

func (a mediaByWidth) Len() int { return len(a) }
func (a mediaByWidth) Less(i, j int) bool {
	// Handle nil width consistently
	if a[i].Width == nil && a[j].Width != nil {
		return false
	} else if a[i].Width != nil && a[j].Width == nil {
		return true
	}

	// Sort by width, then by key for stability
	if a[i].Width == nil || a[j].Width == nil || *a[i].Width == *a[j].Width {
		return a[i].Size < a[j].Size
	}
	return *a[i].Width < *a[j].Width
}
func (a mediaByWidth) Swap(i, j int) { a[i], a[j] = a[j], a[i] }

// SortByWidth sorts the media sizes by width from lowest to highest.
// If a width is nil, it will consistently appear at the end.
func (ms MediaSizes) SortByWidth() []MediaSize {
	// Convert map to slice for deterministic sorting
	sorted := make(mediaByWidth, 0, len(ms))
	for key, mediaSize := range ms {
		mediaSize.Size = key
		mediaSize.MediaSrc = fmt.Sprintf("(min-width: %vpx)", *mediaSize.Width+50)
		sorted = append(sorted, mediaSize)
	}
	sort.Sort(sorted)

	// Convert sorted slice back to original format
	result := make([]MediaSize, len(sorted))
	for i, m := range sorted {
		result[i] = m
	}
	return result
}

func (m Media) Render(w io.Writer) error {
	tpl, err := template.New("").Parse(templates.Picture)
	if err != nil {
		return err
	}
	return tpl.Execute(w, m)
}
